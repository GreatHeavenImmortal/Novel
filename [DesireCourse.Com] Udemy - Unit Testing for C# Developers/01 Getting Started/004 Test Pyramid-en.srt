1
00:00:00,000 --> 00:00:04,000
So, now you know about the different kinds of

2
00:00:04,000 --> 00:00:08,000
automated tests. Unit tests, integration tests, and

3
00:00:08,000 --> 00:00:12,000
end-to-end tests. But what kind of tests should you write in your

4
00:00:12,000 --> 00:00:16,000
application? Well, all of them. This is what we call

5
00:00:16,000 --> 00:00:20,000
the test pyramid. This pyramid argues that most of your

6
00:00:20,000 --> 00:00:24,000
tests should be in the category of unit tests, because these

7
00:00:24,000 --> 00:00:28,000
tests are easy to write, and they execute quickly. But since they

8
00:00:28,000 --> 00:00:32,000
don't give you much confidence about the health of your application, you should have

9
00:00:32,000 --> 00:00:36,000
a bunch of integration tests that test the integration of your

10
00:00:36,000 --> 00:00:40,000
application code with its external dependencies. These

11
00:00:40,000 --> 00:00:44,000
tests provide many advantages of end-to-end tests,

12
00:00:44,000 --> 00:00:48,000
but without the complexities of dealing with the user interface.

13
00:00:48,000 --> 00:00:52,000
And finally, you should write very few end-to-end tests for

14
00:00:52,000 --> 00:00:56,000
the key functions of the application, but you should not test the edge cases with

15
00:00:56,000 --> 00:01:00,000
these end-to-end tests. You only test the happy path,

16
00:01:00,000 --> 00:01:04,000
and leave the edge cases to unit tests. Now this pyramid,

17
00:01:04,000 --> 00:01:08,000
it's just a guideline. It's not a hard and fast rule you need to follow

18
00:01:08,000 --> 00:01:12,000
in every application. The actual ratio between your unit

19
00:01:12,000 --> 00:01:16,000
integration and end-to-end tests, really depends on your project.

20
00:01:16,000 --> 00:01:20,000
Unit tests are great for quickly testing the logic

21
00:01:20,000 --> 00:01:24,000
of conditional statements and loops. If you have methods with

22
00:01:24,000 --> 00:01:28,000
complex logic and calculation, you should test them with your unit tests.

23
00:01:28,000 --> 00:01:32,000
Earlier in the section, I showed you an example of a calculate

24
00:01:32,000 --> 00:01:36,000
function. Unit tests are ideal for testing these

25
00:01:36,000 --> 00:01:40,000
functions, because you can quickly test all the execution paths

26
00:01:40,000 --> 00:01:44,000
of these functions in less than a second. Manually testing these functions

27
00:01:44,000 --> 00:01:48,000
through the user interface takes a significant amount of time and is

28
00:01:48,000 --> 00:01:52,000
prone to errors. However, not every application has

29
00:01:52,000 --> 00:01:56,000
a complex logic, and functions like our calculate function.

30
00:01:56,000 --> 00:02:00,000
You might have an application that simply reads some data from or

31
00:02:00,000 --> 00:02:04,000
writes it to a database. In that case you may need more integration

32
00:02:04,000 --> 00:02:08,000
tests than unit tests. So in summary, this test

33
00:02:08,000 --> 00:02:12,000
pyramid gives you three recommendations. First,

34
00:02:12,000 --> 00:02:16,000
is to favor unit tests over UI or end-to-end

35
00:02:16,000 --> 00:02:20,000
tests. Because these unit tests are the fastest to run,

36
00:02:20,000 --> 00:02:24,000
and cheapest to write, and they're very precise. So we can

37
00:02:24,000 --> 00:02:28,000
pinpoint exactly where something fails. They give you

38
00:02:28,000 --> 00:02:32,000
rapid feedback. Second is to cover the unit test

39
00:02:32,000 --> 00:02:36,000
gaps, with integration tests. And finally, use

40
00:02:36,000 --> 00:02:40,000
end-to-end tests sparingly, only for the key functions of

41
00:02:40,000 --> 00:02:44,000
your application. The right balance is different for each project

42
00:02:44,000 --> 00:02:48,000
and each team. At the end of the day you need to use your own judgement to determine

43
00:02:48,000 --> 00:02:52,000
what kind of tests you need to write for different parts of your applications.
