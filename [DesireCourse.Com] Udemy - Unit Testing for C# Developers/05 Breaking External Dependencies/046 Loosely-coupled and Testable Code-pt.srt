1
00:00:00,000 --> 00:00:04,000
A maioria dos aplicativos legados so criados sem o

2
00:00:04,000 --> 00:00:08,000
teste de unidade em mente. Portanto, para test-los em

3
00:00:08,000 --> 00:00:12,000
unidade,  necessrio refator-los para um design testvel

4
00:00:12,000 --> 00:00:16,000
e fracamente acoplado. Em um design fracamente acoplado, voc pode substituir

5
00:00:16,000 --> 00:00:20,000
um objeto por outro em tempo de execuo. Portanto, quando a unidade testa

6
00:00:20,000 --> 00:00:24,000
uma classe que usa um objeto que fala com um

7
00:00:24,000 --> 00:00:28,000
recurso externo, voc pode substituir esse objeto por um objeto

8
00:00:28,000 --> 00:00:32,000
falso, que chamamos de teste duplo. Agora, h trs etapas que voc precisa seguir

9
00:00:32,000 --> 00:00:36,000
para obter um design testvel e fracamente acoplado. Primeiro, voc extrai o

10
00:00:36,000 --> 00:00:40,000
cdigo que usa um recurso externo em

11
00:00:40,000 --> 00:00:44,000
uma classe separada. Ento voc coloca o cdigo que fala com

12
00:00:44,000 --> 00:00:48,000
um recurso externo em uma classe separada e o isola do resto do seu cdigo.

13
00:00:48,000 --> 00:00:52,000
Em seguida, voc extrai uma interface dessa classe.

14
00:00:52,000 --> 00:00:56,000
Por que uma interface? Porque uma interface  como um contrato.

15
00:00:56,000 --> 00:01:00,000
Ele simplesmente declara vrios mtodos e propriedades, mas nenhum

16
00:01:00,000 --> 00:01:04,000
deles possui uma implementao, nenhum desses mtodos possui cdigo.

17
00:01:04,000 --> 00:01:08,000
Uma interface simplesmente diz ao compilador C # que, em

18
00:01:08,000 --> 00:01:12,000
algum lugar do cdigo, provavelmente h uma ou mais classes

19
00:01:12,000 --> 00:01:16,000
que implementam esse contrato. Ento essas classes implementam

20
00:01:16,000 --> 00:01:20,000
os membros declarados na interface. Voc pode ter duas classes

21
00:01:20,000 --> 00:01:24,000
diferentes que implementam essa interface. Uma  a implementao real

22
00:01:24,000 --> 00:01:28,000
que usa um recurso externo, a outra  a falsa

23
00:01:28,000 --> 00:01:32,000
que chamamos de teste duplo. Finalmente, voc modifica a classe

24
00:01:32,000 --> 00:01:36,000
em teste, voc fala com essa interface em vez de

25
00:01:36,000 --> 00:01:40,000
uma de suas implementaes concretas. Ento, em vez de

26
00:01:40,000 --> 00:01:44,000
depender de uma implementao especfica, ela depender apenas

27
00:01:44,000 --> 00:01:48,000
da interface ou do contrato. Voc pode passar qualquer objeto

28
00:01:48,000 --> 00:01:52,000
que implemente essa interface e, dessa maneira, a classe se

29
00:01:52,000 --> 00:01:56,000
torna fracamente acoplada e testvel. Em termos prticos, isso significa que

30
00:01:56,000 --> 00:02:00,000
voc deve excluir as linhas nas quais voc cria uma instncia de

31
00:02:00,000 --> 00:02:04,000
implementao incorreta usando o novo operador. Porque quando voc usa o

32
00:02:04,000 --> 00:02:08,000
novo operador dentro de uma classe, voc est fazendo essa

33
00:02:08,000 --> 00:02:12,000
classe fortemente ligada ou fortemente dependente de uma determinada implementao.

34
00:02:12,000 --> 00:02:16,000
Ento, no podemos substituir essa implementao em seu teste por

35
00:02:16,000 --> 00:02:20,000
um objeto falso, ok? Portanto, em vez de atualizar

36
00:02:20,000 --> 00:02:24,000
uma implementao especfica, seu programa inicia uma interface ou

37
00:02:24,000 --> 00:02:28,000
um contrato e passa a implementao dessa interface a

38
00:02:28,000 --> 00:02:32,000
partir do exterior. Aqui est uma maneira de fazer isso. Ento, voc pode passar

39
00:02:32,000 --> 00:02:36,000
isso como um parmetro para um mtodo. Voc tambm pode passar uma dependncia

40
00:02:36,000 --> 00:02:40,000
por um construtor ou uma propriedade. Examinaremos exemplos de cada

41
00:02:40,000 --> 00:02:44,000
uma dessas abordagens em breve. Ento, quando voc programa

42
00:02:44,000 --> 00:02:48,000
contra interfaces, voc pode fornecer implementaes diferentes

43
00:02:48,000 --> 00:02:52,000
em momentos diferentes. Em seu cdigo de produo, voc

44
00:02:52,000 --> 00:02:56,000
fornecer a implementao real que fala com um recurso externo em

45
00:02:56,000 --> 00:03:00,000
seus testes, fornecer uma implementao falsa e isso  o que

46
00:03:00,000 --> 00:03:04,000
chamamos de injeo de dependncia. Em vez de novas dependncias, ns

47
00:03:04,000 --> 00:03:08,000
as injetamos do lado de fora. Eu recebo muitos e-mails dos meus alunos me

48
00:03:08,000 --> 00:03:12,000
perguntando, Mosh, o que  injeo de dependncia?  to

49
00:03:12,000 --> 00:03:16,000
complicado. No . Injeo de dependncia  um termo

50
00:03:16,000 --> 00:03:20,000
de 25 dlares para um conceito de 5 centavos. Significa simplesmente injetar ou

51
00:03:20,000 --> 00:03:24,000
suprir as dependncias de uma classe do lado de

52
00:03:24,000 --> 00:03:28,000
fora, e isso faz com que suas classes sejam

53
00:03:28,000 --> 00:03:32,000
fracamente acopladas e testveis. Ento, a seguir, veremos essas trs etapas em ao.

