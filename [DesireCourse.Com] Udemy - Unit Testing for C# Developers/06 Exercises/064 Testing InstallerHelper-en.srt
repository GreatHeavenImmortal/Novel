1
00:00.000 --> 00:04.000
Alright, now in our unit testing project,

2
00:04.000 --> 00:08.000
in the Mocking folder, let's add a new

3
00:08.000 --> 00:12.000
test class called InstallerHelper

4
00:12.000 --> 00:16.000
Tests.

5
00:16.000 --> 00:20.000
We decorate this with test fixture.

6
00:20.000 --> 00:24.000
And also create a Setup method, public void method,

7
00:24.000 --> 00:28.000
SetUp, and decorate this with the SetUp

8
00:28.000 --> 00:32.000
attribute. Now here we need to mock

9
00:32.000 --> 00:36.000
IFileDownloader interface. So, I'm going to

10
00:36.000 --> 00:40.000
create a private field called _file

11
00:40.000 --> 00:44.000
Downloader and initialize it to a new instance

12
00:44.000 --> 00:48.000
of Mock of IFile

13
00:48.000 --> 00:52.000
Downloader. Now here we can press

14
00:52.000 --> 00:56.000
alt and enter to create a private field by this name.

15
00:56.000 --> 01:00.000
So, here's our private field, of type mock

16
01:00.000 --> 01:04.000
of IFileDownloader, okay? Now similarly,

17
01:04.000 --> 01:08.000
we need an installer helper. So, Installer

18
01:08.000 --> 01:12.000
Helper is a new

19
01:12.000 --> 01:16.000
InstallerHelper that takes a FileDownloader object

20
01:16.000 --> 01:20.000
so we pass fileDownloader.object.

21
01:20.000 --> 01:24.000
And then, use the IDE to create this

22
01:24.000 --> 01:28.000
private field. Beautiful. So, our setup is ready

23
01:28.000 --> 01:32.000
now let's create our first test method.

24
01:32.000 --> 01:36.000
So Test public void,

25
01:36.000 --> 01:40.000
the method is called DownloadInstaller.

26
01:40.000 --> 01:44.000
The first scenario is where download fails, so,

27
01:44.000 --> 01:48.000
DownloadFails, this method should Return

28
01:48.000 --> 01:52.000
False. Now in the arrange part

29
01:52.000 --> 01:56.000
we need to program our mock. So,

30
01:56.000 --> 02:00.000
fileDownloader, we use the Setup method,

31
02:00.000 --> 02:04.000
now we pass a lambda expression, fileDownloader goes to

32
02:04.000 --> 02:08.000
when we call the DownloadFile

33
02:08.000 --> 02:12.000
method, and give it two arguments, in this case I'm going to pass

34
02:12.000 --> 02:16.000
empty string and I will tell you why in a second. Then this method,

35
02:16.000 --> 02:20.000
should throw an exception. So throws a web

36
02:20.000 --> 02:24.000
exception because that's the type of exemption we have

37
02:24.000 --> 02:28.000
in our catch block here, okay.

38
02:28.000 --> 02:32.000
So here's the arrange part,

39
02:32.000 --> 02:36.000
now we need to act, so installerHelper.

40
02:36.000 --> 02:40.000
DownloadInstaller. Here we need to pass two arguments.

41
02:40.000 --> 02:44.000
The first one is customer and the second one is installer name.

42
02:44.000 --> 02:48.000
So I can pass a and b as simple values,

43
02:48.000 --> 02:52.000
but someone looking at this code, they don't know exactly what these

44
02:52.000 --> 02:56.000
values are. So in this case I'm going to break the rules that I told you about earlier,

45
02:56.000 --> 03:00.000
and use a descriptive name, so customer,

46
03:00.000 --> 03:04.000
and installer. This makes our test more real (?)

47
03:04.000 --> 03:08.000
Now we get the result, and

48
03:08.000 --> 03:12.000
Assert that result

49
03:12.000 --> 03:16.000
Is False. Let's

50
03:16.000 --> 03:20.000
run the test and see what happens.

51
03:20.000 --> 03:24.000
Our test failed. We expected false,

52
03:24.000 --> 03:28.000
but we got true. How did that happen? Well,

53
03:28.000 --> 03:32.000
something interesting about these mock objects you need to know,

54
03:32.000 --> 03:36.000
is that when you program them using the set up method, this

55
03:36.000 --> 03:40.000
behavior you define in this case, throwing a web exception

56
03:40.000 --> 03:44.000
only happens when we call this download file method

57
03:44.000 --> 03:48.000
to exact same arguments. In other words, if you pass

58
03:48.000 --> 03:52.000
any other argument, this behavior will not happen.

59
03:52.000 --> 03:56.000
So that method will not do anything. In this case,

60
03:56.000 --> 04:00.000
in our installer helper class, this is the argument

61
04:00.000 --> 04:04.000
that we are passing for a FileDownloader.

62
04:04.000 --> 04:08.000
So, to fix our test, we need

63
04:08.000 --> 04:12.000
to replace this empty string with a url like this, http

64
04:12.000 --> 04:16.000
example.com/

65
04:16.000 --> 04:20.000
customer/installer. And

66
04:20.000 --> 04:24.000
for the second argument, instead of an empty string, we should use

67
04:24.000 --> 04:28.000
null. Because if you look at

68
04:28.000 --> 04:32.000
installer helper, the second argument is setupDestination

69
04:32.000 --> 04:36.000
File, and this field is not initialized

70
04:36.000 --> 04:40.000
anywhere. So by default, it's null. Now,

71
04:40.000 --> 04:44.000
back to our test. With these arguments,

72
04:44.000 --> 04:48.000
if you run this test, it should pass. Let's verify that.

73
04:48.000 --> 04:52.000
Okay, beautiful, it passed.

74
04:52.000 --> 04:56.000
However, I don't quite like the way

75
04:56.000 --> 05:00.000
we have written this test. It's getting a little bit noisy, it's

76
05:00.000 --> 05:04.000
long (?) string. And this is a simplified example. Sometimes in your

77
05:04.000 --> 05:08.000
applications you may not even have access to that argument

78
05:08.000 --> 05:12.000
that is sent to a given method like DownloadFile. In that case,

79
05:12.000 --> 05:16.000
you want to program this mock in more

80
05:16.000 --> 05:20.000
generic way. So, instead of this first argument,

81
05:20.000 --> 05:24.000
we can pass It, this is one of the classes

82
05:24.000 --> 05:28.000
defined in mock. It has a method called IsAny

83
05:28.000 --> 05:32.000
which is generic, then we pass a string.

84
05:32.000 --> 05:36.000
Similarly, I'm going to use this for the second argument, so it is

85
05:36.000 --> 05:40.000
any string. Like this.

86
05:40.000 --> 05:44.000
Now, our mock is more generic.

87
05:44.000 --> 05:48.000
So when we call DownloadFile, with any arguments,

88
05:48.000 --> 05:52.000
it's going to throw this web exception, okay?

89
05:52.000 --> 05:56.000
Now finally, let's reformat this code to make it a little more readable.

90
05:56.000 --> 06:00.000
Like this. Let's run the test

91
06:00.000 --> 06:04.000
one more time.

92
06:04.000 --> 06:08.000
It's passing. Beautiful. Now, the second test.

93
06:08.000 --> 06:12.000
So, to save time, I'm going to duplicate

94
06:12.000 --> 06:16.000
this method, change the scenario

95
06:16.000 --> 06:20.000
from download fails to download

96
06:20.000 --> 06:24.000
completes, and we expect

97
06:24.000 --> 06:28.000
to get true. So here we don't need to

98
06:28.000 --> 06:32.000
program our mock, because by default when we call this download

99
06:32.000 --> 06:36.000
file method, it doesn't do anything, it doesn't throw an exception, and we don't expect

100
06:36.000 --> 06:40.000
a value here either. So, let's delete that.

101
06:40.000 --> 06:44.000
And finally let's Assert that result is true.

102
06:44.000 --> 06:48.000
Let's run the test.

103
06:48.000 --> 06:52.000
Beautiful. Now here's a question for you.

104
06:52.000 --> 06:56.000
You might ask, Mosh, here we are writing a test

105
06:56.000 --> 07:00.000
for this web exception and we Assert that result should be false.

106
07:00.000 --> 07:04.000
What if this download file method throws

107
07:04.000 --> 07:08.000
a different kind of exception at run time. Should we

108
07:08.000 --> 07:12.000
write another test and program our mock

109
07:12.000 --> 07:16.000
to throw a different kind of exception? No, we don't have to

110
07:16.000 --> 07:20.000
do that. Because the whole purpose of this method.

111
07:20.000 --> 07:24.000
is to return true if the download completes, and false,

112
07:24.000 --> 07:28.000
if download fails. So web exception is specifically

113
07:28.000 --> 07:32.000
the kind of exception that may happen when downloading a file. If you

114
07:32.000 --> 07:36.000
get a different kind of exception, let's say null reference exception,

115
07:36.000 --> 07:40.000
or argument out of range exception, or divide by zero exception,

116
07:40.000 --> 07:44.000
we don't want to hide that exception by returning false.

117
07:44.000 --> 07:48.000
So we want that exception to be propagated, perhaps there is

118
07:48.000 --> 07:52.000
an exception logger somewhere programmed globally, so that's going to

119
07:52.000 --> 07:56.000
get that exception and log it somewhere. Only want to return

120
07:56.000 --> 08:00.000
false if we get a web exception, and for that very reason

121
08:00.000 --> 08:04.000
we don't need to write another test for this method.