1
00:00:00,000 --> 00:00:04,000
Tudo bem, ento, aqui na

2
00:00:04,000 --> 00:00:08,000
pasta Mocking, vamos adicionar uma

3
00:00:08,000 --> 00:00:12,000
nova classe EmployeeStorage. Algumas pessoas podem preferir chamar

4
00:00:12,000 --> 00:00:16,000
isso de EmployeeService, mas eu pessoalmente prefiro no usar a

5
00:00:16,000 --> 00:00:20,000
palavra service, porque o servio est sobrecarregado na comunidade, pode

6
00:00:20,000 --> 00:00:24,000
significar coisas diferentes, ele tambm tem diferentes significados dependendo de

7
00:00:24,000 --> 00:00:28,000
em qual camada ele  usado, eu pessoalmente usar servios

8
00:00:28,000 --> 00:00:32,000
para implementar uma camada de servio de aplicativo.

9
00:00:32,000 --> 00:00:36,000
Uma camada de servio de aplicativo  uma camada em torno de seu aplicativo que

10
00:00:36,000 --> 00:00:40,000
 responsvel pela orquestrao de alto nvel. Por isso, ele delega

11
00:00:40,000 --> 00:00:44,000
tarefas para objetos diferentes. Por exemplo, ele pode conversar com

12
00:00:44,000 --> 00:00:48,000
um objeto para armazenar algo em um banco de dados e, em seguida,

13
00:00:48,000 --> 00:00:52,000
ele pode conversar com outro objeto para enviar uma notificao ao usurio e,

14
00:00:52,000 --> 00:00:56,000
finalmente, pode falar com um objeto logger para gravar algo no log.

15
00:00:56,000 --> 00:01:00,000
Ento, isso  o que chamamos de orquestrao de alto nvel.

16
00:01:00,000 --> 00:01:04,000
E quando tenho cenrios como esse, uso a palavra service. Mas, neste caso, no temos uma orquestrao

17
00:01:04,000 --> 00:01:08,000
de alto nvel, no precisamos de uma camada de servio de aplicativo. Tudo o

18
00:01:08,000 --> 00:01:12,000
que voc est fazendo  excluir um funcionrio de nosso banco de dados.

19
00:01:12,000 --> 00:01:16,000
 por isso que eu prefiro chamar essa classe de EmployeeStorage.

20
00:01:16,000 --> 00:01:20,000
Porque  puramente responsvel pelo armazenamento. Agora voc pode perguntar

21
00:01:20,000 --> 00:01:24,000
por que eu no chamei este EmployeeRepository.

22
00:01:24,000 --> 00:01:28,000
Bem, certamente poderamos fazer isso, mas os repositrios no devem ter

23
00:01:28,000 --> 00:01:32,000
um mtodo de salvar. Ento no podemos chamar de ressositrio. salvar

24
00:01:32,000 --> 00:01:36,000
as alteraes. Eu expliquei a razo para isso em meu curso de

25
00:01:36,000 --> 00:01:40,000
estrutura de edio e tambm escrevi posts sobre isso. Ento, basta procurar por

26
00:01:40,000 --> 00:01:44,000
Mosh Hamedani, padro de repositrio. Voc ver que tenho alguns posts

27
00:01:44,000 --> 00:01:48,000
sobre repositrio e como voc deve us-los. Ento, se voc quiser usar um padro de repositrio

28
00:01:48,000 --> 00:01:52,000
aqui, voc tambm deve trazer um prmio unitrio (? ) e isso torna este

29
00:01:52,000 --> 00:01:56,000
projeto um pouco mais complicado. Ento  por isso que

30
00:01:56,000 --> 00:02:00,000
eu prefiro usar um EmployeeStorage em vez de EmployeeRepository e

31
00:02:00,000 --> 00:02:04,000
unit award (? ) neste contexto. Ento,

32
00:02:04,000 --> 00:02:08,000
EmployeeStorage deve ter um

33
00:02:08,000 --> 00:02:12,000
mtodo, DeleteEmployee, que leva

34
00:02:12,000 --> 00:02:16,000
um inteiro. Agora, de volta ao nosso controlador,

35
00:02:16,000 --> 00:02:20,000
vou pegar essas trs linhas. Cortar.

36
00:02:20,000 --> 00:02:24,000
E mova-o dentro deste mtodo. Ento, aqui voc pode ver

37
00:02:24,000 --> 00:02:28,000
que precisamos de uma referncia ao nosso contexto de banco

38
00:02:28,000 --> 00:02:32,000
de dados, ento vou voltar ao nosso controlador e mover

39
00:02:32,000 --> 00:02:36,000
esse campo privado para nossa classe de armazenamento tambm.

40
00:02:36,000 --> 00:02:40,000
E finalmente, vamos inicializar isso

41
00:02:40,000 --> 00:02:44,000
no construtor. Ento, um novo EmployeeContext.

42
00:02:44,000 --> 00:02:48,000
E a propsito, esse cdigo tem um bug, porque nessa

43
00:02:48,000 --> 00:02:52,000
linha  possvel que no encontremos um funcionrio com esse ID.

44
00:02:52,000 --> 00:02:56,000
Ento quando passarmos null aqui, vamos obter uma exceo.

45
00:02:56,000 --> 00:03:00,000
Ento, eu vou modificar isso para o funcionrio

46
00:03:00,000 --> 00:03:04,000
no  nulo, ento vamos remov-lo do contexto

47
00:03:04,000 --> 00:03:08,000
e salvar as alteraes, ok? Ou, outra maneira de reescrever

48
00:03:08,000 --> 00:03:12,000
este cdigo  inverter esta declarao condicional e ento

49
00:03:12,000 --> 00:03:16,000
voc pode se livrar deste bloco de cdigo e

50
00:03:16,000 --> 00:03:20,000
este recuo extra. Deixe-me mostrar o que quero dizer. Ento, se

51
00:03:20,000 --> 00:03:24,000
o funcionrio  nulo, ento podemos

52
00:03:24,000 --> 00:03:28,000
retornar imediatamente, certo? E com isso ns no

53
00:03:28,000 --> 00:03:32,000
precisamos mais deste bloco de cdigo, e esse recuo extra.

54
00:03:32,000 --> 00:03:36,000
Como isso.

55
00:03:36,000 --> 00:03:40,000
Ok, ento este  o nosso armazenamento de funcionrios,  puramente responsvel por

56
00:03:40,000 --> 00:03:44,000
trabalhar com nosso banco de dados. Agora, nesta implementao, estamos

57
00:03:44,000 --> 00:03:48,000
usando algum (? ) para o conseguir.

58
00:03:48,000 --> 00:03:52,000
Talvez amanh ns decidamos usar uma estrutura diferente, ou voc pode decidir

59
00:03:52,000 --> 00:03:56,000
usar uma conexo sequela simples e comandos sequenciais para excluir um funcionrio

60
00:03:56,000 --> 00:04:00,000
de um banco de dados. Isso  detalhe de implementao

61
00:04:00,000 --> 00:04:04,000
e pode mudar no futuro. Nosso controlador no se

62
00:04:04,000 --> 00:04:08,000
importa com esse detalhe de implementao, desde que

63
00:04:08,000 --> 00:04:12,000
este EmployeeStorage tenha um mecanismo para excluir um

64
00:04:12,000 --> 00:04:16,000
funcionrio, nosso controlador ficar satisfeito. Ento, agora precisamos extrair uma

65
00:04:16,000 --> 00:04:20,000
interface dessa classe. Ento alt e digite. Refator

66
00:04:20,000 --> 00:04:24,000
extrair interface. E vamos

67
00:04:24,000 --> 00:04:28,000
adicionar esse membro. Ok, pronto.

68
00:04:28,000 --> 00:04:32,000
Ento, aqui est nossa nova interface, agora

69
00:04:32,000 --> 00:04:36,000
precisamos injetar isso no construtor do nosso

70
00:04:36,000 --> 00:04:40,000
EmployeeController, ento, aqui atrs, no construtor IEmployeeStorage.

71
00:04:40,000 --> 00:04:44,000
Vamos chamar esse armazenamento e criar

72
00:04:44,000 --> 00:04:48,000
e inicializar um campo privado de

73
00:04:48,000 --> 00:04:52,000
uma s vez. Portanto, no precisamos mais criar um novo funcionrio.

74
00:04:52,000 --> 00:04:56,000
Contexto, em vez disso, temos um campo

75
00:04:56,000 --> 00:05:00,000
privado do tipo IEmployeeStorage. Agora, finalmente,

76
00:05:00,000 --> 00:05:04,000
em nosso mtodo DeleteEmployee, precisamos

77
00:05:04,000 --> 00:05:08,000
chamar o armazenamento. DeleteEmployee e passe

78
00:05:08,000 --> 00:05:12,000
este ID aqui. Assim, podemos ver com essa refatorao

79
00:05:12,000 --> 00:05:16,000
que temos uma separao adequada das preocupaes. Em nenhum lugar do

80
00:05:16,000 --> 00:05:20,000
nosso controlador estamos tocando nosso banco de dados,

81
00:05:20,000 --> 00:05:24,000
toda essa responsabilidade  encapsulada dentro do nosso armazenamento.

